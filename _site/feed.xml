<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Libao Blog</title>
    <description>关于前端与设计、黑客与画家 | 黄玄，Web &amp; Mobile Lover，Front-End Engineer，UX Designer | 这里是 @Hux黄玄 的个人博客，与你一起发现更大的世界。</description>
    <link>http://devxulibao.com/</link>
    <atom:link href="http://devxulibao.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 16 Jan 2016 16:42:36 +0800</pubDate>
    <lastBuildDate>Sat, 16 Jan 2016 16:42:36 +0800</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>to-my-love</title>
        <description>&lt;p&gt;祝远在南京的你 生日快乐！&lt;/p&gt;

&lt;p&gt;总是会去YY以后在一起的日子会有多幸福，而在此之前，所能做的只是努力努力再努力。&lt;/p&gt;

&lt;p&gt;一起为了我们的未来而努力拼搏吧。&lt;/p&gt;

&lt;p&gt;祝你生日快乐^_^&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://callmewhy.qiniudn.com/hh.JPG&quot; alt=&quot;&quot; /&gt;—&lt;/p&gt;

</description>
        <pubDate>Tue, 05 Jan 2016 20:00:00 +0800</pubDate>
        <link>http://devxulibao.com/2016/01/05/miui6/</link>
        <guid isPermaLink="true">http://devxulibao.com/2016/01/05/miui6/</guid>
        
        <category>最爱</category>
        
        <category>的你</category>
        
        <category>生日</category>
        
        <category>快乐</category>
        
        
      </item>
    
      <item>
        <title>Hello 2016</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;””&lt;br /&gt;
## 前言&lt;br /&gt;
2015就这样过去了，我想聊一聊这一年的收获和感想。很感谢在这一年陪我一起学习进步的小伙伴们。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;学习&lt;/h2&gt;

&lt;p&gt;这一年的时间里，我感觉收获最大的地方就是学习了。并不是学习给我带来了什么，而是学习方法本身的收获。之前对很多问题总是避之不见，就是像我下面要说的伸手党。好吧，可以说任何职业可以孰能生巧，但是冒尖的一定是那些会自主学习，自己探索的。多说一句，想法是建立在思考上的。常年不会思考的人一个很棒的想法不会光顾在你身上的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;掌握属于自己的学习方法，循序渐进提高效率。&lt;/li&gt;
  &lt;li&gt;静下心来学习，戒骄戒躁，专注与技术本身。&lt;/li&gt;
  &lt;li&gt;有自己的职业规划，清楚自己需要什么在做什么。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于我而言，学习分为三个过程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;大量阅读&lt;/li&gt;
  &lt;li&gt;整理消化&lt;/li&gt;
  &lt;li&gt;乐于分享&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;大量阅读&lt;/h3&gt;

&lt;p&gt;第一步是大量阅读。&lt;/p&gt;

&lt;p&gt;充分保证阅读量是高效学习的前提，而阅读量主要取决于以下方面：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;信息来源：有哪些渠道来收集信息&lt;/li&gt;
  &lt;li&gt;关注焦点：大量的信息里如何取舍&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我的阅读来源主要是（排名有先后）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RSS：订阅了很多博客，以前主要是 iOS ，现在主要是前端。好处是可以第一时间获取到最新的博客分享，而且不会遗漏。一般我只在 Mac 上用 Reeder 处理订阅的内容，方便归档整理。订阅列表会定期同步到 Gist 上。&lt;/li&gt;
  &lt;li&gt;周报：邮箱里订阅了很多技术周报，比如 Swift Sandbox 、iOS Dev Weekly 等等，周报可以起到一个查漏补缺的作用，因为这是其他开发者手机整理的，如果发现有好的博客则可以整理到自己的 RSS 里方便以后长期关注。&lt;/li&gt;
  &lt;li&gt;微博：前面两个信息来源都是自己主动订阅的，可以保证质量但是并不能保证阅读的广度。我的微博里有一个专门的 Learn 分组，里面存放了近两百个质量比较高的微博帐号，可以及时看到一些微博上的技术分享，这个分组里的微博是每天每条必读的。看到不错的内容会收藏，然后每周清理微博里的收藏。&lt;/li&gt;
  &lt;li&gt;其他：其他就比较杂了，比如社交平台（GitHub 、Twitter）、比如资讯网站（Hacker News、Product Hunt）、比如技术论坛（cnode.org、div.io），等等。还有各种杂七杂八的技术分享、微信订阅号的各种日报周报、不定时地看一些 TED 视频之类的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我关注的内容很杂，前端、iOS、设计、语言等诸多方面都会看一下，并不说有那么多时间去关注这么多内容，而是相比于其他过程，信息收集的过程成本很低。在收集的过程中多关注一些东西，以后在需要的时候很容易就会联想到自己在这方面的知识储备。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;整理消化&lt;/h3&gt;

&lt;p&gt;有了大量的信息输入之后，接下来就是整理和消化。&lt;/p&gt;

&lt;p&gt;我一般会把所有的资料都整理到 Pocket 里，以前还会打个 tag 标记一下关键词，后来发现并没有打 tag 的必要，反正看了标题也就知道是什么内容了，而且有时候会在打什么 tag 上纠结很久，比如《如何使用 Swift+NodeJS+Nginx 搭建属于自己的 RESTFul API》，你说这是属于 iOS 还是 Web 还是 Swift 还是 RESTFul 呢？尴尬，干脆不打。&lt;/p&gt;

&lt;p&gt;然后就遇到了一个问题：每天会有将近百篇新文章输入，而我并没有那么多时间阅读。所以现在屯了一千多篇未读的文章。这是个问题呐，收集起来虽然成本不高，但是总是堆在那里也是碍事啊。于是早晨的地铁我会尽量浏览我攒下的文章，不必要都仔细看，留有一个印象，遇到感兴趣的或者特别好的我会记着。晚上下班回家我会选择拥堵最厉害的公交车，有时候能堵上两个小时（北京的交通你懂的），车上的时候正好可以看很多东西，有一段时候我会每天晚上把电脑都带在身上，在公交上浏览一些我的Git上拉的很多大牛推荐的优秀源码。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;乐于分享&lt;/h3&gt;

&lt;p&gt;博客是一种很好的记录方式:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方便总结：可以把自己阶段性的教训和经验详细记录下来，总结的过程也就是整理和思考的过程。&lt;/li&gt;
  &lt;li&gt;方便回顾：以后再遇到类似的问题可以很快找到自己当初的总结，翻翻笔记就可以快速进入状态。&lt;/li&gt;
  &lt;li&gt;方便交流：最大的好处就是可以和其他人一起讨论，别人的疑惑和经验有利于更深入的思考问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了博客，这一年还参与了各种技术分享会。线下技术分享，基本是各取所需，不要指望『听君一席话，胜读十年书』这种速成，有所启发就足够了。像 QCon 和 CFF 在会后都有视频，感觉比线下听更有效率。我比较热衷与参加技术分享倒不是希望学到什么（感觉技术分享上听到的内容基本博客里都写遍了），而是喜欢一群人一起讨论自己所热爱的东西，比如 Swift ，比如 FRP ，比如 Docker 。说直白点其实就是去找归属感。在这个三十分钟精通 C++ 二十天速成 iOS 每个人都想着年薪百万的时代里，有一群纯粹的热爱技术的程序员兴高采烈地分享自己所热爱的东西，是多么幸福的一件事。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;保持专注&lt;/h3&gt;

&lt;p&gt;这个单独拎出来，因为它很！重！要！很多人遇到个什么问题就火急火燎的去请教别人，『请问大神这个怎么办？』，『请问大神怎么才能这样？』。这样的结果往往是单纯的解决问题，对自己却没有任何提高。『是啊，没有提高！』于是有人又要火急火燎的问，『然后没有提高怎么办？』。&lt;/p&gt;

&lt;p&gt;怎么办个屁啊！&lt;/p&gt;

&lt;p&gt;搬个凳子，坐下来，歇着。静静的思考自己遇到的问题，需要解决什么，如何解决，有哪些方案，怎样效率最高，下一步该怎么做。都想清楚了，再去回想前面自己的问题。比如如何用 NodeJS 写爬虫，如果连爬虫是什么都不清楚就到处提问『如何使用 NodeJS 写爬虫』，怎么可能解决问题？&lt;/p&gt;

&lt;p&gt;授人以鱼不如授人以渔。我呼吁各位，再遇到伸手党，可以告诉他 Google 的正确打开方式。&lt;/p&gt;

&lt;p&gt;如果在群里遇到执迷不悟的伸手党，请这样做。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;大喊：蜀将安在！&lt;/li&gt;
  &lt;li&gt;找个托呼应：末将在！&lt;/li&gt;
  &lt;li&gt;大喊：大刑伺候！&lt;/li&gt;
  &lt;li&gt;祭出下图：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/61d238c7gw1ez47jpma7lj207d0byt9d.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再来说下专注。这里的专注，是指专注于思考问题本身，而不是想着怎么样尽快解决问题。为什么遇到问题去请教别人总能解决？并不是因为别人天生比你厉害多少，很大一部分原因是因为你在到处求解答求帮忙的时候，别人在静静的写代码。工作业务很繁忙，人际关系很复杂，但是一定要专注自己想要做的东西。如果想做一名优秀的开发者，那就专注技术本身；如果想做一个熟练的伸手党，那，嗯哼。&lt;/p&gt;

&lt;p&gt;专注的另一个方面，就是不要被杂音干扰。今天 bang 开源了 JSPatch ，于是一窝蜂涌过去，『大神好厉害，求教求教』；明天 YY 火了，一群人又围上去，『国内还有如此大牛太厉害了』。四处追星，何时学习？&lt;/p&gt;

&lt;p&gt;他们是否厉害？是，确实很厉害，代码质量也很高。但是和去吹捧去羡慕去崇拜相比，更应该做的是静心做学问。不要盲目追星盲目造星盲目调侃。很多人到处问，『怎么才能学好 iOS』，『怎么才能想大牛们一样厉害啊』。连基本学习和思考的过程都没有，每天提这些问题，就像是捧着个空钱包每天问马云我什么时候才能成为百万富翁一样。&lt;/p&gt;

&lt;p&gt;这是我的一点个人感想。虽然作为一名段子手，我是半个身子处于娱乐圈的人，但是作为一名软件工程师，我觉得静心做学问才是自己真正的追求。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;学习习惯&lt;/h3&gt;

&lt;p&gt;学习习惯前面有聊了很多，不过是比较通用的，属于每天的学习积累。在遇到具体问题的时候还是需要具体分析：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通读文档：不管什么技术，一定是文档优先。原因很简单：时效性和准确性。技术更新的速度很快，尤其是前端，只有官方文档才是最及时最准确的。&lt;/li&gt;
  &lt;li&gt;善用搜索：一定要善用搜索引擎，思考怎么样才能让搜索引擎理解你想问的问题，可以多搜多对比。一定一定一定，不要用百度。&lt;/li&gt;
  &lt;li&gt;多读代码：对于开发而言，多阅读优秀的代码。比如学 iOS 的时候就看看 ForkingDog 或者 AFNetworking ，自然而然总结一些最佳实践。&lt;/li&gt;
  &lt;li&gt;保持交流：上面可以满足基础的学习，但是对于一些最佳实践的思考和总结，还是要多和别人交流，多看别人的分享，多和别人分享，查漏补缺。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;一专多能&lt;/h3&gt;

&lt;p&gt;感觉多看一些东西多掌握一些技术对于自己的成长是很有帮助的。专攻某一项技术并不简单地意味着不去了解其他技术。&lt;/p&gt;

&lt;p&gt;比如做 iOS 开发，Cocoa 的底层技术肯定需要熟悉的，但是有其他方面的技术积累。比如需要经常变动的需求或许就可以考虑用 Hybrid 的方案，比如需要做个简单的小游戏或许 Cocos2d-x 和 Unity3D 会是更好地选择，比如有天写了个脚本之后发现自动更新版本号然后打包上传发布的全自动化操作是如此的方便。而如果一直局限于『iOS 开发』这个技术领域，或许就会错过很多东西。&lt;/p&gt;

&lt;p&gt;个人认为全栈是软件工程师成长之后的必然结果。但是千万不要为了全栈而全栈。比如什么『NodeJS 真好，学完之后前端工程师就能写后端了，就是全栈工程师了』，什么『快去学 React Native 啊学完就能开发客户端了就是全栈工程师了』。如果学习的目的是为了收集『全栈工程师』这个称号，那学习这件事本身就已经变了味了。&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;规划&lt;/h2&gt;

&lt;p&gt;最近不少小伙伴处于对现有工作不满意，在观望的状态，我想就这方面再聊一聊。&lt;/p&gt;

&lt;p&gt;找工作大概是这么几个选择：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;稳定安逸的成熟大厂，适合希望找一份稳定工作的同学们，每天十点上班，然后下午四点跑步洗澡，晚上看书参与一些翻译活动，感觉生活的很舒适。然而大厂的 KPI 考核是比较恶心的。当工作变成了演戏，那编程的乐趣便也少了许多。&lt;/li&gt;
  &lt;li&gt;发展不错的创业公司，可以理解为半创业模式。适合有能力且想挑战一下的同学。创业公司能活下来，基本上团队质量是说得过去的。不妨去网上找一些口碑不错的创业公司，投投简历，四处聊聊，找一家投缘的留下来发展。创业公司会比较灵活一些，你的建议和想法很快能得到反馈，一定程度上来讲，合作效率也会更好。&lt;/li&gt;
  &lt;li&gt;从零起步的创业团队，这就不多说了。除非真的是有很好的机遇和很强的创业欲望，否则还是不要考虑了。如果在犹豫要不要出来创业，或许已经不合适了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;风险越高回报越高，天上没那么多馅饼可以掉。看准了一定要尽早做决定，不要优柔寡断。时间过的很快，等着等着就没了。&lt;/p&gt;

&lt;p&gt;我对自己的定位是『工程型编程爱好者』，本身工作就是爱好，爱好就是工作。所以一直是想出来和朋友创业，除了想改变世界，另一方面也是想满足自己的理想，打造自己的技术团队，让更多的人真正体会编程的乐趣，为自己喜欢的事情做点什么。&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;人生&lt;/h2&gt;

&lt;p&gt;知乎上常常有”人活着为什么要努力”,之类的问题.&lt;/p&gt;

&lt;p&gt;我想起来庄子《逍遥游》里的一句话.&lt;/p&gt;

&lt;p&gt;蜩与学鸠笑之曰：我决起而飞，抢榆枋，时则不至，而控于地而已矣。奚以之九万里而南为？&lt;/p&gt;

&lt;p&gt;努力,是为了看到更大的世界.&lt;/p&gt;

&lt;p&gt;更重要的是.&lt;/p&gt;

&lt;p&gt;人生短短五十年,如梦似幻.&lt;/p&gt;

&lt;p&gt;我他妈不想输.&lt;/p&gt;
</description>
        <pubDate>Sat, 02 Jan 2016 08:00:00 +0800</pubDate>
        <link>http://devxulibao.com/2016/01/02/hello-2016/</link>
        <guid isPermaLink="true">http://devxulibao.com/2016/01/02/hello-2016/</guid>
        
        <category>活着</category>
        
        <category>2016</category>
        
        <category>北京</category>
        
        
      </item>
    
      <item>
        <title>Definition of End to End User Scenarios</title>
        <description>&lt;h3 id=&quot;end-to-end&quot;&gt;End to end?&lt;/h3&gt;

&lt;p&gt;To explain what is “End to End User Scenarios”, we should first explain what is “End to End”, which we can called E2E for short.&lt;/p&gt;

&lt;p&gt;There is not a very clear definition of E2E in wiki.&lt;sup&gt;&lt;a href=&quot;#ref1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; In dictionary, it can both refer to “throughout” or “the end of one object connect to the end of another object”.&lt;sup&gt;&lt;a href=&quot;#ref2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; &lt;/p&gt;

&lt;p&gt;E2E is usually used in Logistics, Computer Networking and Software Testing. For example, End-to-end testing is a methodology used to test whether the flow of an application is performing as designed from start to finish. The entire application is tested in a real-world scenario.&lt;/p&gt;

&lt;p&gt;So in my view, the most essential part of E2E is that &lt;strong&gt;we must focus on the entire process, including every parts in a use case.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;user-scenarios&quot;&gt;User Scenarios!&lt;/h3&gt;

&lt;p&gt;User scenarios is a common term in UX Design,&lt;sup&gt;&lt;a href=&quot;#ref3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt;&lt;sup&gt;&lt;a href=&quot;#ref4&quot;&gt;[4]&lt;/a&gt;&lt;/sup&gt; which expands upon our persona and user stories by including details. It told us about users’ motivation, goals and actions on our products. &lt;/p&gt;

&lt;p&gt;To make it better, there comes &lt;strong&gt;“End to End User Scenarios”, not just tell a fragment of users’ activities, but pay attention to the entire process the user undergoes.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;That means we should consider the whole things from the start point that user want to use our products to the ended up point that user get results and leave our products.&lt;/p&gt;

&lt;p&gt;Only when we know &lt;strong&gt;who&lt;/strong&gt; does &lt;strong&gt;what&lt;/strong&gt; on our products, &lt;strong&gt;how&lt;/strong&gt; and &lt;strong&gt;why&lt;/strong&gt; they do it, can we define design requirements concrete enough to actually meet them. So it really helps us to improve our UX of our products.&lt;/p&gt;

&lt;h3 id=&quot;lets-go-deeper&quot;&gt;Let’s go deeper…&lt;/h3&gt;

&lt;p&gt;We just put the two terms together and give it a explanation, but it can be farther. When we truly design an experience, End to End User Scenarios can helps more:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Extend the scope&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There is a interesting instance &lt;sup&gt;&lt;a href=&quot;#ref5&quot;&gt;[5]&lt;/a&gt;&lt;/sup&gt; told that sometimes we are already satisfy of our designed UX, but if we look beyond the both ends of the designed experience by extending the scope of the timeline before and after… we may sadly realize that it’s a complete car crash outside the scope of the designed experience…  &lt;/p&gt;

&lt;p&gt;Try to extend the scope and consider more, so can we design a much broader experience for our user.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Shorten the path&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;UX Designers always dive into a User Flow and try to shorten the user paths. The idea of End to End User Scenarios can do the same things.&lt;/p&gt;

&lt;p&gt;For example, in the past, if I want to know the weather today. I should typically visit a search engine website, input and search “weather”, click the first link that search result page shows, then jump into a kind of weather website like “The Weather Channel”, and finally, I got today’s weather information!&lt;/p&gt;

&lt;p&gt;But wait! &lt;strong&gt;Just consider it using “End to End User Scenarios”&lt;/strong&gt;, I just want to know about weather so I use search engine right? why should I took a so long user path to get there? Smart Search Engine should told me the weather directly.&lt;/p&gt;

&lt;p&gt;That is what all search engine have doing nowadays.&lt;/p&gt;

&lt;h3 id=&quot;in-sum&quot;&gt;In sum&lt;/h3&gt;

&lt;p&gt;There is many design tools like “End to End User Scenarios” were used by designers, they are really awesome. But the most essential things in my opinion is, still, always thinking about user. All this tools are powerful only based on a truly user-centric mind.&lt;/p&gt;

&lt;p&gt;From my perspective, the “End to End User Scenarios” can be generally defined as &lt;strong&gt;“Entire Process Considered, User Requirement Centric, Anticipated Experince Design”.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;That’s all, thank you.&lt;/p&gt;

&lt;h3 id=&quot;references&quot;&gt;References&lt;/h3&gt;

&lt;p&gt;1.&lt;a id=&quot;ref1&quot;&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/End-to-end&quot;&gt;End-to-end - Wikipedia, the free encyclopedia&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.&lt;a id=&quot;ref2&quot;&gt;&lt;a href=&quot;http://www.thefreedictionary.com/end-to-end&quot;&gt;end-to-end - definition of end-to-end by The Free Dictionary&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.&lt;a id=&quot;ref3&quot;&gt;&lt;a href=&quot;http://blog.usabilla.com/how-user-scenarios-help-to-improve-your-ux/&quot;&gt;How User Scenarios Help To Improve Your UX - The Usabilla Blog&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.&lt;a id=&quot;ref4&quot;&gt;&lt;a href=&quot;https://www.newfangled.com/how-to-tell-the-users-story/&quot;&gt;How to Create User Stories, Scenarios, and Cases&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5.&lt;a id=&quot;ref5&quot;&gt;&lt;a href=&quot;http://www.90percentofeverything.com/2008/11/11/designing-end-to-end-user-experiences/&quot;&gt;Designing end-to-end user experiences. | 90 Percent Of Everything&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 21 Nov 2015 00:00:00 +0800</pubDate>
        <link>http://devxulibao.com/2015/11/21/e2e_user_scenarios/</link>
        <guid isPermaLink="true">http://devxulibao.com/2015/11/21/e2e_user_scenarios/</guid>
        
        <category>交互设计</category>
        
        <category>English-only</category>
        
        <category>UX Design</category>
        
        
      </item>
    
      <item>
        <title>操作系统的浪漫主义 —— Metro 篇</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;操作系统的背后不只是冷冰冰的 0 和 1 ，数字时代的设计师们，如初神般刻画着新世界的秩序。信息、量子、宇宙，他们取世间万物为灵感来表达自己，那是它们对数字时代最浪漫的隐喻。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;操作系统，数字时代当之无愧的地基。当大部分从业人员都更关注它的技术与功能时，操作系统的 UI 设计师们却赋予了它无限的艺术气息：他们用充满着浪漫主义幻想色彩的设计语言，配合着物理定律般严谨的交互体系，描绘着自己心目中的数字世界，那些界面 的背后是他们对数字世界的思考、理解、期待、抽象与隐喻，&lt;strong&gt;这些艺术思想支撑着浮在表面的设计&lt;/strong&gt;。他们用一切你熟悉或不熟悉的方式，告诉世人：  &lt;/p&gt;

&lt;p&gt;&lt;em&gt;“看呐，那个虚拟又真实的世界”&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;metro&quot;&gt;Metro&lt;/h2&gt;

&lt;p&gt;我们第一个要聊的，就是 &lt;a href=&quot;http://en.wikipedia.org/wiki/Metro_(design_language\)&quot;&gt;Metro&lt;/a&gt; 。虽然它已经改名为 Modern UI ，虽然它作为 Windows Phone 、Windows 8 甚至 Windows 10 的 UI 风格算不上成功，但是作为一个设计语言，它却是声名显赫。以它而非 Windows 来命名这一章节，就是出于对它的敬意。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-metro-ui.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;众所周知 Metro 借鉴了交通标示语言、包豪斯现代风格与瑞士国际主义平面设计，其核心思想在于剔除多余信息，专注于内容传达（Content, not chrome），所以 Metro 采用了以 Typography、Color 为主要元素的视觉语言，另外它也非常重视动效设计（Motion Design），这是同期 UI 设计的共识，Motion provides meaning，动效对于表达隐喻有着巨大得作用。&lt;/p&gt;

&lt;p&gt;我们暂且不去讨论 Metro 在实际运用中的情况，而是尝试去猜想一下 Metro 的设计师们对数字世界的思考，以及那些隐藏在 Metro 背后的奇思妙想：&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;思考 —— 极致抽象信息&lt;/h4&gt;

&lt;p&gt;数字时代是基于信息的。这也是为什么我们称这个产业为 IT (Information Technology) ，我们每天使用 PC、Mobile 等数字设备、其实本质是主动或被动的接收、筛选、消化与产生信息。&lt;/p&gt;

&lt;p&gt;语言与文字的发明是人类信息革命的第一个里程碑，掌握同种语言或文字的人类从此可以高效得进行信息的交换与传播。而现在我们正在走进人机交互与万物互联的时代：人类不但要和人类通信，还要和智能设备建立连接。历史总是上演着重复因此值得借鉴，为什么不把已经发明的东西在数字世界重新发明一次呢？&lt;strong&gt;于是 Cortana 承担了微软在数字时代复刻语音的使命，而 Metro 则继承了老祖宗文字的魔力。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;无论 Typography-based 还是 Content, not chrome ，&lt;strong&gt;Metro 试图对一切数字时代的信息进行一种非常极致的抽象 —— 我们的 UI 不需要来自真实世界的隐喻，我们只需要足够直接的信息。&lt;/strong&gt; 既然文字就是信息、图片就是信息、音视频就是信息，所以它们理所当然应该直接呈现；而所有的样式也都必须直接传达信息，于是网格和灰度表示层级，颜色的存在也更多代表着符号化的视觉传达：比如用于 VI 的品牌色，或者是刻板印象心情。&lt;/p&gt;

&lt;p&gt;这种对信息简单粗暴的抽象使得 Metro 的首秀极具冲击，却也成为其日后发展最大的绊脚石。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;载体 —— 信息平面&lt;/h4&gt;

&lt;p&gt;信息总归需要载体，而设计师们的目的就是寻找，或者创造一种介质来承载、传递、可视化这些信息，然后呈现给用户， 最后才得以成为 UI &lt;/p&gt;

&lt;p&gt;我们都看着屏幕越来越趋于一种扁平的状态，所有设计师们理所当然的想到这种介质可能是一种类似平面的东西，比如说 WebOS 具有抽象意义的“卡片纸” ，或是 iOS/OS X 改变风格前使用的“亚麻桌布”，他们尝试告诉你藏在屏幕后面的数字世界，可能是由某种类似真实世界的平面状物体来承载信息的。  &lt;br /&gt;
而 Metro 则做得更加彻底，在它看来这种拟物是强加给数字世界的不必要信息，于是它抛开了所有自然界存在的元素，又一次将信息抽象做到了极致 ：其实那就是一个单纯放置信息的平面而已，或者说，&lt;strong&gt;其实是信息组成了这个平面，数字世界的信息根本无需额外的载体——文字与图像，一方面可以看作是狭义信息的载体，另一方面也可以被看作是广义信息的一种表现形态。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;所以我们可以看到 Metro UI 的背景经常是一个空旷的黑色，其实那个黑色代表着 Nothing ，意味着这个平面的下方没有任何东西。&lt;/strong&gt;而如果你在下方使用了图像作为背景，你就会发现这其实是两个平面 —— 上层是一个背景透明、漂浮在图像层上的信息平面。而下层则是另一个完全由图像信息组成的信息平面，当我们去划动上层时，产生的视差移动也在告诉我们：这是两个层级。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-metro-panorama.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在所有的 Metro 组件里，我印象最深刻的叫 Panorama Panel（上图） ，Panorama 在我看来是 Metro 对信息最直接的隐喻：&lt;strong&gt;不同的信息体，聚合成了一个完整的信息平面&lt;/strong&gt;。当我们在手机屏幕上左右滑动 Panorama 时就好像在操作一个摄像机平移镜头。这种“数字报纸”区别于报纸的最大感受就好像它可以随着信息的量级在 X 轴和 Y 轴 上无限延伸下去，变成一个信息的海洋，在你的面前流动。&lt;/p&gt;

&lt;p&gt;对啊，那不就是信息流吗。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;世界 —— 卡片飞舞的世界&lt;/h4&gt;

&lt;p&gt;我之所以不愿称 Metro 的信息平面为纸片，是因为它不能卷曲也不能折叠；  &lt;br /&gt;
而之所以不愿称 Metro 的信息平面为卡片，是因为它并非实体，而且尺寸无限；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;可 Metro 的世界却又让我觉得是卡片飞舞的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一张卡片的秩序是动态磁贴（Live Tiles），它很硬，只能翻转。却又具备魔力，好像在每一次的翻转中，信息都可以得到重组和再现。  &lt;br /&gt;
二张卡片的秩序是视差原理（Parallax），当你移动镜头时，任意两张卡片在你眼中的位移，都必须由它们距离屏幕 (Z=0) 的深度决定  &lt;br /&gt;
三张卡片的秩序就像飞来咒，原有的平面撤离，被呼唤的卡片俏皮的翻滚着从侧后方飞进视野，Metro UI 的动画设计隐喻着一切。&lt;/p&gt;

&lt;p&gt;Status Bar 和 Application Bar 就像是紧贴在屏幕上的卡片，所以不受视差影响。而 Pivot Control 则更有魔幻色彩一点，你操纵它就如操作交通枢纽，指挥一个个小的信息片，来来去去在你的面前。&lt;/p&gt;

&lt;p&gt;所有这些零厚度的卡片，或近，或远，最终组成了整个 Metro 世界。&lt;strong&gt;在我的想象里，那个次元就好像，所有的信息都以片状飞在空中，而你只能看见你所需要的那些，它们有条不紊的在纵横间穿梭，就好像到处都是信息流的交通轨道，你仿佛置身于，那个数据包飞来飞去、路由器控制地址的 —— 网路世界。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-metro-real.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-4&quot;&gt;结语&lt;/h2&gt;

&lt;p&gt;Metro 对信息极致的抽象与压平，与同期的 iOS 6- 风格形成鲜明对比，引发大家对于数字世界与用户界面的新一轮思考，里程碑式的推动了 Flat Design 在新一代数字设计中的普及。不过我们也知道 Metro UI 在微软的实际运用中却其实不成功，这又是为什么呢？&lt;/p&gt;

&lt;p&gt;笔者抛砖引玉一些自己的观点：  &lt;/p&gt;

&lt;p&gt;当年 Metro 第一次运用在 Zune 身上时是非常惊艳的，风格超前、细节精致、动画细腻。再看现在的 Xbox （图一），Pivot 配合磁贴组、简单大气，几乎成为电视 UI 设计的模版。可偏偏在 PC 和 Mobile 两个场景，Metro 却饱受非议。&lt;/p&gt;

&lt;p&gt;在我看来 PC 和 Mobile 其实代表着两个信息密度最高的场景、PC 是传统互联网的计算中心，而 Mobile 则是移动互联网和可以预见的未来内的个人计算中心。&lt;br /&gt;
&lt;strong&gt;在如此复杂的场景下，其实 Metro 作为设计语言的尺度是不够的。&lt;/strong&gt;为什么这么说呢，虽然 Metro 对信息的抽象方式不无道理，但其实还是过分理想和纯粹了。有太多的屏幕像素因此被浪费，有太多其他维度的信息表达方式因此被舍弃掉了。&lt;/p&gt;

&lt;p&gt;也就是说：Metro 这个设计语言本身是没有问题的，但是拿目前的它作为 PC/Mobile 这种操作系统级别的设计语言却是存在问题的。&lt;strong&gt;一个操作系统的设计语言与交互体系，一定不能太小，必须是一套包容性足够强又可被拓展和延伸的体系。&lt;/strong&gt;其实我们能看到 Windows Phone 的 UI 设计容纳度是非常低的，这或许就可以说明问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这也是为什么 Win 10 for PC 和 Win 10 for Mobile 都开始削弱最初的那个纯粹的 Metro 体系，转而采用一种 Metro 的视觉语言混搭非 Metro 交互逻辑的方式来设计。&lt;/strong&gt;&lt;br /&gt;
期待 new Metro (Metro 2.0) 能在 Win 10 上逐步走向成熟，让我们一同见证。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;本文是“操作系统的浪漫主义”系列的第一篇文章，如果您喜欢，请继续关注我的博客 ;)&lt;/p&gt;

&lt;p&gt;尽请期待：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Android 篇&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;思考 —— 从卡片的层叠说起&lt;/li&gt;
      &lt;li&gt;载体 —— 量子纸&lt;/li&gt;
      &lt;li&gt;世界 —— 魔法材质统一世界&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;iOS 篇&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;思考 —— 盒子里的蒸汽朋克&lt;/li&gt;
      &lt;li&gt;载体 —— 景深的无穷近与无穷远&lt;/li&gt;
      &lt;li&gt;世界 —— 小宇宙里的小宇宙&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 15 Nov 2015 00:00:00 +0800</pubDate>
        <link>http://devxulibao.com/2015/11/15/os-metro/</link>
        <guid isPermaLink="true">http://devxulibao.com/2015/11/15/os-metro/</guid>
        
        <category>UX Design</category>
        
        <category>Windows</category>
        
        <category>Metro</category>
        
        <category>OS</category>
        
        
      </item>
    
      <item>
        <title>Unix/Linux 扫盲笔记</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;This document is not completed and will be updated anytime.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;catagory&quot;&gt;Catagory&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;#unix&quot;&gt;Unix&lt;/a&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#bell-labs&quot;&gt;Bell Labs&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#xenix&quot;&gt;Xenix&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#bsd&quot;&gt;BSD&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#freebsd--apple&quot;&gt;FreeBSD &amp;amp; Apple&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#nextstep&quot;&gt;NeXTStep&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#darwin&quot;&gt;Darwin&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#posix&quot;&gt;POSIX&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#unix-like&quot;&gt;Unix-like&lt;/a&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#single-unix-specification&quot;&gt;Single Unix Specification&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#apple-ios&quot;&gt;Apple iOS&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#xnu-kernel&quot;&gt;XNU Kernel&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#linux&quot;&gt;Linux&lt;/a&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#linux-kernel&quot;&gt;Linux Kernel&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#gnu-project&quot;&gt;GNU Project&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#android&quot;&gt;Android&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#android-kernel&quot;&gt;Android Kernel&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#android-rom&quot;&gt;Android ROM&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#chrome-os&quot;&gt;Chrome OS&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#chromium-os&quot;&gt;Chromium OS&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;unix&quot;&gt;Unix&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Unix is a &lt;strong&gt;family&lt;/strong&gt; of multitasking, multiuser computer OS.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Derive from the original &lt;strong&gt;AT&amp;amp;T Unix&lt;/strong&gt;, Developed in the 1970s at &lt;strong&gt;Bell Labs&lt;/strong&gt; (贝尔实验室), initially intended for use inside the &lt;strong&gt;Bell System&lt;/strong&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;bell-labs&quot;&gt;Bell Labs&lt;/h4&gt;
    &lt;p&gt;Bell 和 AT&amp;amp;A 在那时已经是一家了，可以看到那时的通信公司真是一线 IT 公司呢。 &lt;br /&gt;
&lt;strong&gt;C 语言也是 Bell Labs 的产物&lt;/strong&gt;，从一开始就是为了用于 Unix 而设计出来的。所以 Unix （在 73 年用 C 重写）在高校流行后，C 语言也获得了广泛支持。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;AT&amp;amp;T licensed Unix to outside parties(第三方) from the late 1970s, leading to a variety of both &lt;strong&gt;academic&lt;/strong&gt; (最有有名的 BSD ) and &lt;strong&gt;commercial&lt;/strong&gt; (Microsoft Xenix, IBM AIX, SunOS Solaris)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;xenix&quot;&gt;Xenix&lt;/h4&gt;
    &lt;p&gt;微软 1979 年从 AT&amp;amp;A 授权来的 Unix OS，配合着 x86 成为当时最受欢迎的 Unix 发行版。后来 M$ 和 IBM 合作开发 OS/2 操作系统后放弃，后来最终转向 &lt;strong&gt;Windows NT&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;bsd&quot;&gt;BSD&lt;/h4&gt;
    &lt;p&gt;&lt;strong&gt;Barkeley Software Distribution&lt;/strong&gt;, also called Berkeley Unix. Today the term “BSD” is used to refer to any of the BSD descendants(后代) which together form a branch of the family of Unix-like OS.(共同组成了一个分支)&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;BSD 最大的贡献是在 BSD 中率先增加了虚拟存储器和 Internet 协议&lt;/strong&gt;，其 TCP/IP(IPv4 only) 代码仍然在现代 OS 上使用（ Microsoft Windows and most of the foundation of Apple’s OS X and iOS ）&lt;/li&gt;
      &lt;li&gt;BSD 后来发展出了众多开源后代，包括 FreeBSD, OpenBSD, NetBSD 等等……很多闭源的 vendor Unix 也都从 BSD 衍生而来。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;freebsd--apple&quot;&gt;FreeBSD &amp;amp; Apple&lt;/h4&gt;
    &lt;p&gt;FreeBSD 不但是 Open Source BSD 中占有率最高的，还直接影响了 Apple Inc : NeXT Computer 的团队在 FreeBSD 上衍生出了 NeXTSTEP 操作系统，这货后来在 Apple 时期演化成了 &lt;strong&gt;Darwin&lt;/strong&gt; ，这个“达尔文”居然还是个开源系统，而且是 the Core of &lt;strong&gt;Mac OS X&lt;/strong&gt; and &lt;strong&gt;iOS&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;nextstep&quot;&gt;NeXTSTEP&lt;/h4&gt;
    &lt;p&gt;An &lt;strong&gt;object-oriented&lt;/strong&gt;, multitasking OS. Low-level C but High-level OC language and runtime the first time, combined with an &lt;strong&gt;OO aplication layer&lt;/strong&gt; and including several “kits”.    &lt;br /&gt;
大家都知道 NeXT 是 Steve Jobs 被 forced out of Apple 后和 a few of his coworkers 创办的，所以 &lt;strong&gt;NeXTSTEP 绝对是证明 Jobs 实力的作品。&lt;/strong&gt; &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;darwin&quot;&gt;Darwin&lt;/h4&gt;
    &lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Darwin_(operating_system\)&quot;&gt;Darwin&lt;/a&gt;, the core set of components upon which Mac OS X and iOS based, mostly POSIX compatible, but has never, by itself, been certified as being compatible with any version of &lt;strong&gt;POSIX&lt;/strong&gt;. (OS X, since Leopard, has been certified as compatible with the Single UNIX Specification version 3)  &lt;br /&gt;
&lt;strong&gt;所以说 Mac OS X 算是很正统 Unix 的了&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;posix&quot;&gt;POSIX&lt;/h4&gt;
    &lt;p&gt;可移植操作系统接口, Portable Operating System Interface, is a family of standards specified by the IEEE from maintaining compatibility between OS, defines the API along with Command Line Shells and utility interfaces, for software comaptibility with variants of Unix and other OS.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Fully POSIX compliant:
        &lt;ul&gt;
          &lt;li&gt;OS X&lt;/li&gt;
          &lt;li&gt;QNX OS (BlackBerry)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Mostly complicant:
        &lt;ul&gt;
          &lt;li&gt;Linux&lt;/li&gt;
          &lt;li&gt;OpenBSD/FreeBSD&lt;/li&gt;
          &lt;li&gt;Darwin (Core of &lt;strong&gt;iOS&lt;/strong&gt; &amp;amp; OS X)&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;Android&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Complicant via compatibility feature （通过兼容功能实现兼容）
        &lt;ul&gt;
          &lt;li&gt;Windows NT Kernel
            &lt;ul&gt;
              &lt;li&gt;Windows Server 2000, 2003, 2008, 2008 R2, 2012&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Symbian OS (with PIPS)
            &lt;ul&gt;
              &lt;li&gt;Symbian was a closed-source OS.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;unix-like&quot;&gt;Unix-like&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;A Unix-like (sometimes referred to as UN*X or *nix) operating system is one that behaves in a manner similar to a Unix system, while not necessarily conforming to or being certified to any version of the &lt;strong&gt;Single UNIX Specification&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There is no standard for defining the term.  &lt;br /&gt;
其实 Unix-like 是个相对模糊的概念：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;最狭义的 Unix 单指 Bell Labs’s Unix &lt;/li&gt;
  &lt;li&gt;稍广义的 Unix 指代所有 Licensed Unix, 即通过了 SUS 的 Unix-like ，比如 OS X&lt;/li&gt;
  &lt;li&gt;最广义的 Unix 即所有 Unix-like 系统，无论它是否通过过任何 SUS，包括 Linux，BSD Family 等&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;single-unix-specification&quot;&gt;Single UNIX Specification&lt;/h4&gt;
&lt;p&gt;The Single UNIX Specification (SUS) is the collective name of a family of standards for computer OS, compliance with which is required to &lt;strong&gt;qualify for the name “Unix”&lt;/strong&gt;, like &lt;strong&gt;POSIX&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&quot;apple-ios&quot;&gt;Apple iOS&lt;/h4&gt;
&lt;p&gt;iOS is a &lt;strong&gt;Unix-like OS based on Darwin(BSD)&lt;/strong&gt; and OS X, which share some frameworks including Core Foundation, Founadtion and the Darwin foundation with OS X, but, Unix-like shell access is not avaliable for users and restricted for apps, &lt;strong&gt;making iOS not fully Unix-compatible either.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The iOS kernal is &lt;strong&gt;XNU&lt;/strong&gt;, the kernal of Darwin.&lt;/p&gt;

&lt;h4 id=&quot;xnu-kernel&quot;&gt;XNU Kernel&lt;/h4&gt;
&lt;p&gt;XNU, the acronym(首字母缩写) for &lt;strong&gt;&lt;em&gt;X is Not Unix&lt;/em&gt;&lt;/strong&gt;, which is the &lt;strong&gt;Computer OS Kernel&lt;/strong&gt; developed at Apple Inc since Dec 1996 for use in the Mac OS X and released as free open source software as part of Darwin.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;linux&quot;&gt;Linux&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Linux is a Unix-like and mostly POSIX-compliant computer OS.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/commons/thumb/c/cd/Unix_timeline.en.svg/800px-Unix_timeline.en.svg.png&quot; alt=&quot;Unix_timeline&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;linux-kernel&quot;&gt;Linux Kernel&lt;/h4&gt;

&lt;p&gt;严格来讲，术语 Linux 只表示 &lt;a href=&quot;http://en.wikipedia.org/wiki/Linux_kernel&quot;&gt;Linux Kernel&lt;/a&gt; 操作系统内核本身，比如说 Android is Based on Linux (Kernel). Linus 编写的也只是这一部分，一个免费的 Unix-like Kernel，并不属于 GNU Project 的一部分。&lt;/p&gt;

&lt;p&gt;但通常把 Linux 作为 Linux Kernel 与大量配合使用的 GNU Project Software Kit (包括 Bash, Lib, Compiler, 以及后期的 GUI etc) 所组合成的 OS 的统称。（包括各类 Distribution 发行版）&lt;/p&gt;

&lt;p&gt;这类操作系统也被称为 &lt;strong&gt;GNU/Linux&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;gnu-project&quot;&gt;GNU Project&lt;/h4&gt;

&lt;p&gt;The GNU Project is a &lt;strong&gt;free software, mass collaboration&lt;/strong&gt; project, which based on the following freedom rights:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Users are free to run the software, share (copy, distribute), study and modify it.&lt;/li&gt;
  &lt;li&gt;GNU software guarantees these freedom-rights legally (via its license).&lt;/li&gt;
  &lt;li&gt;So it is not only FREE but, more important, FREEDOM.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In order to ensure that the &lt;em&gt;entire&lt;/em&gt; software of a computer grants its users all freedom rights (use, share, study, modify), even the most fundamental and important part, &lt;strong&gt;the operating system&lt;/strong&gt;, needed to be written. &lt;/p&gt;

&lt;p&gt;This OS is decided to called &lt;strong&gt;GNU (a recursive acronym meaning “GNU is not Unix”)&lt;/strong&gt;. By 1992, the GNU Project had completed all of the major OS components except for their kernel, &lt;em&gt;GNU Hurd&lt;/em&gt;. &lt;/p&gt;

&lt;p&gt;With the release of the third-party &lt;strong&gt;Linux Kernel&lt;/strong&gt;, started independently by &lt;em&gt;Linus Torvalds&lt;/em&gt; in 1991 and released under the GPLv0.12 in 1992, for the first time it was possible to run an OS &lt;strong&gt;composed completely of free software&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Though the Linux kernel is not part of the GNU project, it was developed using GCC and other GNU programming tools and was released as free software under the GPL.&lt;/p&gt;

&lt;p&gt;Anyway, there eventually comes to the &lt;strong&gt;GNU/Linux&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;GPL&lt;/strong&gt;: GNU General Public License&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GCC&lt;/strong&gt;: GNU Compiler Collection&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其他与 GPL 相关的自由/开源软件公共许可证：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Mozilla_Public_License&quot;&gt;Mozilla Public License&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/MIT_License&quot;&gt;MIT License&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/BSD_licenses&quot;&gt;BSD Public License&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;GPL 强制后续版本必须是自由软件，而 BSD 的后续可以选择继续开源或者封闭	&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Apache_License&quot;&gt;Apache License&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://dl2.iteye.com/upload/attachment/0047/4142/d770c85a-49b7-3c7f-8ae2-cbb6451e00d8.png&quot; alt=&quot;Public License&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;android&quot;&gt;Android&lt;/h4&gt;

&lt;p&gt;Android is a mobile OS based on &lt;strong&gt;Linux Kernel&lt;/strong&gt;, so it’s definitely &lt;strong&gt;Unix-like&lt;/strong&gt;.  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Linux is under GPL so Android has to be open source&lt;/strong&gt;. &lt;br /&gt;
Android’s source code is released by Google under open source licenses, although most Android devices ultimately ship with a combination of open source and proprietary software, including proprietary software developed and licensed by Google &lt;em&gt;(GMS are all proprietary)&lt;/em&gt;  &lt;/p&gt;

&lt;h4 id=&quot;android-kernel&quot;&gt;Android Kernel&lt;/h4&gt;

&lt;p&gt;Android’s kernel is based on one of the Linux kernel’s long-term support (LTS) branches.   &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Android’s variant of the Linux kernel&lt;/strong&gt; has further architectural changes that are implemented by Google outside the typical Linux kernel development cycle, and, certain features that Google contributed back to the Linux kernel. Google maintains a public code repo that contains their experimental work to re-base Android off the latest stable Linux versions.&lt;/p&gt;

&lt;p&gt;Android Kernel 大概是 Linux Kernel 最得意的分支了，Android 也是 Linux 最流行的发行版。不过，也有一些 Google 工程师认为 Android is not Linux in the traditional Unix-like Linux distribution sense. 总之这类东西就算有各种协议也还是很难说清楚，在我理解里 Android Kernel 大概就是 fork Linux Kernel 之后改动和定制比较深的例子。&lt;/p&gt;

&lt;h4 id=&quot;android-rom&quot;&gt;Android ROM&lt;/h4&gt;

&lt;p&gt;既然提到 Android 就不得不提提 Android ROM &lt;/p&gt;

&lt;p&gt;ROM 的本义实际上是只读内存：  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Read-only memory&lt;/strong&gt; (ROM) is a class of storage medium used in computers and other electronic devices. Data stored in ROM can only be modified slowly, with difficulty, or not at all, so it is &lt;strong&gt;mainly used to distribute firmware (固件)&lt;/strong&gt; (software that is very closely tied to specific hardware, and unlikely to need frequent updates).&lt;/p&gt;

&lt;p&gt;ROM 在发展的过程中不断进化，从只读演变成了可编程可擦除，并最终演化成了 Flash  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PROM (Programmable read-only memory)&lt;/li&gt;
  &lt;li&gt;EPROM (Erasable programmable read-only memory)&lt;/li&gt;
  &lt;li&gt;EEPROM (Electrically erasable programmable read-only memory)
    &lt;ul&gt;
      &lt;li&gt;Flash memory (闪存) &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Flash 的出现是历史性的，它不但可以作为 ROM 使用，又因其极高的读写速度和稳定性，先后发展成为U盘（USB flash drives）、移动设备主要内置存储，和虐机械硬盘几条街的固态硬盘（SSD），可以说这货基本统一了高端存储市场的技术规格。&lt;/p&gt;

&lt;p&gt;所以我们平时习惯说的 ROM 其实还是来源于老单片机时代，那时的 ROM 真的是写了就很难（需要上电复位）、甚至无法修改，所以那时往 ROM 里烧下去的程序就被称作 firmware ，固件。久而久之，虽然技术发展了，固件仍然指代那些不常需要更新的软件，而 ROM 这个词也就这么沿用下来了。&lt;/p&gt;

&lt;p&gt;所以在 wiki 里是没有 Android ROM 这个词条的，只有 &lt;a href=&quot;http://en.wikipedia.org/wiki/List_of_custom_Android_firmwares&quot;&gt;List of custom Android firmwares&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A custom firmware, also known as a custom ROM, ROM, or custom OS, is an aftermarket distribution of the Android operating system. They are based on the Android Open Source Project (AOSP), hence most are open-sourced releases, unlike proprietary modifications by device manufacturers.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;各类 Android ROM 在 Android 词类下也都是属于 &lt;strong&gt;Forks and distributions&lt;/strong&gt; 一类的。&lt;/p&gt;

&lt;p&gt;所以我说，其实各类 Android ROM 也好，fork Android 之流的 YunOS、FireOS 也好，改了多少东西，碰到多深的 codebase ……&lt;strong&gt;其实 ROM 和 Distribution OS 的界限是很模糊的&lt;/strong&gt;，为什么 Android 就不可以是移动时代的 Linux ，为什么 Devlik/ART 就不能是移动时代的 GCC 呢？&lt;/p&gt;

&lt;h4 id=&quot;chrome-os&quot;&gt;Chrome OS&lt;/h4&gt;

&lt;p&gt;Chrome OS is an operating system based on the &lt;strong&gt;Linux kernel&lt;/strong&gt; and designed by Google to work with web applications and installed applications. &lt;/p&gt;

&lt;p&gt;虽然目前只是个 Web Thin Client OS ，但是 RoadMap 非常酷……&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Chrome Packaged Application&lt;/strong&gt; (Support working offline and installed)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Android App Runtime&lt;/strong&gt; (run Android applications natively…fxxking awesome)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;平复一下激动的心情，还是回到正题来：&lt;/p&gt;

&lt;h4 id=&quot;chromium-os&quot;&gt;Chromium OS&lt;/h4&gt;

&lt;p&gt;Chrome OS is based on Chromium OS, which is the open-source development version of Chrome OS, which is a &lt;strong&gt;Linux distribution&lt;/strong&gt; designed by Google.&lt;/p&gt;

&lt;p&gt;For Detail, Chromium OS based on &lt;a href=&quot;http://en.wikipedia.org/wiki/Gentoo_Linux&quot;&gt;Gentoo Linux&lt;/a&gt;, emm…&lt;/p&gt;

</description>
        <pubDate>Sat, 24 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://devxulibao.com/2015/10/24/unix-linux-note/</link>
        <guid isPermaLink="true">http://devxulibao.com/2015/10/24/unix-linux-note/</guid>
        
        <category>OS</category>
        
        <category>Unix</category>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>「知乎」如何评价 2015 年 3 月 9 日 Apple 春季发布会？</title>
        <description>&lt;div&gt;
    &lt;blockquote&gt;一个 gay，一个 gay-like ，带着 Apple 向着&lt;b&gt;新式奢侈品&lt;/b&gt;的方向飞去了。&lt;/blockquote&gt;
    &lt;br /&gt;无论是 Apple Watch ，还是 new MacBook，这次发布会都象征着 Apple 更明显的转型。
    &lt;br /&gt;
    &lt;br /&gt;不应该再把 Apple 跟 Microsoft 简单粗暴的对比，它们的受众产生了愈大的差异。两家公司对数字时代有着完全不同的战略，它们改变世界的思路，跟盖茨-乔布斯时代比有着更巨大的分歧。
    &lt;br /&gt;
    &lt;br /&gt;MS 还是 MS，就像纳德拉 7 月的全员信，微软的战略还是回到了&lt;b&gt;“生产力”。&lt;/b&gt;其实微软对“极致”，对“未来”的追求是一种很直观的，我们最初理解的科技，比如手势交互、虚拟现实、机器化自动化、高效办公什么的。微软的受众更多的也还是面向生产力、工作群体（工程师、办公人员）。所以软狗们在知乎永远可以说微软 blah blah，因为对于这部分场景，微软确实有着不可替代的牛逼。
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;而 Apple 则逐渐转变成为数字时代的 LV。&lt;/b&gt;这并不是说它放弃了科技，而是“科技追求极致”的另一种可能性 —— 科技与人文的交汇，甚至是科技与时尚的跨界融合。
    &lt;br /&gt;
    &lt;br /&gt;让我们来稍稍想象一下未来：
    &lt;br /&gt;
    &lt;br /&gt;科技与生活的融合一定是越来越紧密的。更多的“物件”将与科技结合，而这些智能设备也将越来越普及，它们面向的人群，会越来越宽，直到覆盖所有人。
    &lt;br /&gt;可以说现在的科技还是很生硬的，我们很容易把科技和 Geek、Nerd 联系在一起。当一个东西和科技沾边时，我们往往会很清楚的意识到：“哦，这是一个科技产品”，于是我们忽略了其他东西，更多的去关注它的科技性（功能性），但是未来不一样。
    &lt;br /&gt;未来的科技将会很平常，未来的科技将会更加隐形，就像现在的眼镜、家具、衣服、箱包……普通人谁还会在乎它们背后复杂的材料科学与工艺？我们只会觉得它们是生活必需品，然后去在乎它们的外观、舒适性，挑选自己喜欢的产品。
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;科技也一样，当科技无处不在时，我们对“科技产品”本身的功能性要求，就不再是唯一的考量。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;LV 的包之所以成为奢侈品，不止是因为“当它作为一个包时，它的功能性（选材、做工）非常优秀，结实耐用”，还因为它的艺术性，观赏性，精致感，幸福感，社会价值等等，带来的种种溢价。
    &lt;br /&gt;
    &lt;br /&gt;而 Apple Watch、new MacBook，很明显在做相同的事情。
    &lt;br /&gt;
    &lt;br /&gt;说到奢侈，“奢侈”这两个字，在我国基本上是贬义的，词典里的翻译是&lt;b&gt;“挥霍浪费钱财，过分追求享受”&lt;/b&gt;，但 Luxury 在英文中其实要中性许多。
    &lt;br /&gt;
    &lt;br /&gt;与旧式奢侈相比，新奢侈主义在这一代中产消费者中则被广泛接受。所谓新奢侈主义指的是在同类产品中服务质量更高，品位更高的产品，让消费者心驰神往。它们价格不菲，但是还不至于昂贵到可望不可即。
    &lt;br /&gt;
    &lt;blockquote&gt;德国的实业家拉茨勒在《奢侈带来富足》(2001)一书中对旧式奢侈和新式奢侈做过有趣的论述。他以手机为例说明了两种方式的不同：如果一部手机是因为其先进的技术和为客户提供超值的功能而使价格出众，那么生产和消费这样的手机就是需要倡导的新式奢侈；相反，如果一部手机不是因为卓越的技术性能，而是因为手机套上了嵌有钻石的黄金外壳而使得价格昂贵，那么生产和消费这样的手机就是令人憎恶的旧式奢侈。
        &lt;br /&gt;
    &lt;/blockquote&gt;补充一下：&lt;b&gt;这句话出自 2001 年，放在现在来看其实并不是完全适用的。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;手机对当今社会的意义早已不是简单的通讯设备。真正的区别还是在那句话：“Design is about how it works”，&lt;b&gt;新式奢侈的内涵在于产品的某个设计是真的有意义，还是单纯的为了贵而贵。&lt;/b&gt;
    &lt;br /&gt;对于当今数码产品，工业设计、艺术设计是其作为消费品非常重要的部分，如果你是为了给用户提供更多的外观选择而使用黄金，或是为了硬度使用钻石。而不是单纯的堆砌它们来增加价格，那么这些设计都是符合“新式奢侈”的内涵的。
    &lt;br /&gt;
    &lt;br /&gt;所以当我们回过头看看 new MacBook，私以为是&lt;b&gt;数字产品界新式奢侈品&lt;/b&gt;的典型。
    &lt;br /&gt;
    &lt;br /&gt;当我们吐槽 Apple 为了极致的轻薄牺牲了主频、风扇、接口，当我们吐槽买它就是买电池，当我们拿它与 MBA、MBP、Surface 对比吐槽它的 “参数/价钱比” ……
    &lt;br /&gt;
    &lt;br /&gt;其实人家的受众是那些有消费能力追求生活质量的 Sir or Lady，它们并不需要天天对着电脑做开发、重型办公或者打游戏，对于只需要便携安静（轻薄＋续航＋无风扇）、看看电影（Retina Display）、又希望无时不刻彰显自己的品味与身份（外观优雅＋极致设计）的他们来说，new Macbook 简直是最适合“佩戴”的轻奢品。
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;有人说 Apple Watch 简直是 Jony Ive 这个一心向往做奢侈品设计的天才将 Apple 引入了歧途里，而我却觉得&lt;b&gt;科技与时尚的结合为何就不是一件美丽的事情？&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;p&gt;
    &lt;/p&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 20 Oct 2015 20:00:00 +0800</pubDate>
        <link>http://devxulibao.com/2015/10/20/apple-event-2015/</link>
        <guid isPermaLink="true">http://devxulibao.com/2015/10/20/apple-event-2015/</guid>
        
        <category>知乎</category>
        
        <category>职业病</category>
        
        <category>Apple</category>
        
        <category>Macbook</category>
        
        <category>Apple Watch</category>
        
        
      </item>
    
      <item>
        <title>Hello，My Blog</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“Yeah It’s on. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;我的 Blog 就这么开通了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#build&quot;&gt;跳过废话，直接看技术实现 &lt;/a&gt; &lt;/p&gt;

&lt;p&gt;2015 年，我总算有个地方可以好好写点东西了。&lt;/p&gt;

&lt;p&gt;作为一个程序员， Blog 这种轮子要是挂在大众博客程序上就太没意思了。一是觉得大部分 Blog 服务都太丑，一点都不极客！二是觉得不能随便定制不好玩。之前因为太懒没有折腾，结果就一直连个写 Blog 的地儿都没有。&lt;/p&gt;

&lt;p&gt;我一直有做一个个人网站的冲动，自己本身是做iOS的，在网上关注一些业界大牛都会有自己的博客网站，很是漂亮，咦，好想做一个！一不做二不休，花点时间搞一个吧！&lt;/p&gt;

&lt;p id=&quot;build&quot;&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;接下来说说搭建这个博客的技术细节。  &lt;/p&gt;

&lt;p&gt;正好之前就有关注过 &lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt; + &lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt; 快速 Building Blog 的技术方案，非常轻松时尚。&lt;/p&gt;

&lt;p&gt;其优点非常明显：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Markdown&lt;/strong&gt; 带来的优雅写作体验&lt;/li&gt;
  &lt;li&gt;非常熟悉的 Git workflow ，&lt;strong&gt;Git Commit 即 Blog Post&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机
    &lt;ul&gt;
      &lt;li&gt;如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了 &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Jekyll 的自定制非常容易，基本就是个模版引擎&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本来觉得最大的缺点可能是 GitHub 在国内访问起来太慢，所以第二天一起床就到 GitCafe(Chinese GitHub Copy) 迁移了一个&lt;a href=&quot;http://huxpro.gitcafe.io&quot;&gt;镜像&lt;/a&gt;出来，结果还是巨慢。&lt;/p&gt;

&lt;p&gt;哥哥可是个前端好嘛！ 果断开 Chrome DevTool 查了下网络请求，原来是 &lt;strong&gt;pending 在了 Google Fonts&lt;/strong&gt; 上，页面渲染一直被阻塞到请求超时为止，难怪这么慢。  &lt;br /&gt;
忍痛割爱，只好把 Web Fonts 去了（反正超时看到的也只能是 fallback ），果然一下就正常了，而且 GitHub 和 GitCafe 对比并没有感受到明显的速度差异，虽然 github 的 ping 值明显要高一些，达到了 300ms，于是用 DNSPOD 优化了一下速度。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;配置的过程中也没遇到什么坑，基本就是 Git 的流程，相当顺手&lt;/p&gt;

&lt;p&gt;大的 Jekyll 主题上直接 fork 了 Clean Blog（这个主题也相当有名，就不多赘述了。唯一的缺点大概就是没有标签支持，于是我给它补上了。）&lt;/p&gt;

&lt;p&gt;本地调试环境需要 &lt;code&gt;gem install jekyll&lt;/code&gt;，结果 ”rubygem 的源居然被墙了……后来手动改成淘宝的镜像源才成功&lt;/p&gt;

&lt;p&gt;Theme 的 CSS 是基于 Bootstrap 定制的，看得不爽的地方直接在 Less 里改就好了（平时更习惯 SCSS 些），&lt;strong&gt;不过其实我一直觉得 Bootstrap 在移动端的体验做得相当一般，比CSS 框架差多了……&lt;/strong&gt;所以为了体验，也补了不少 CSS 进去&lt;/p&gt;

&lt;p&gt;最后就进入了耗时反而最长的&lt;strong&gt;做图、写字&lt;/strong&gt;阶段，也算是进入了&lt;strong&gt;写博客&lt;/strong&gt;的正轨，因为是类似 Hack Day 的方式去搭这个站的，所以折腾折腾着大半夜就过去了。&lt;/p&gt;

&lt;p&gt;第二天考虑中文字体的渲染，fork 了 &lt;a href=&quot;http://www.typeisbeautiful.com/&quot;&gt;Type is Beautiful&lt;/a&gt; 的 &lt;code&gt;font&lt;/code&gt; CSS，调整了字号，适配了 Win 的渣渲染，中英文混排效果好多了。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;完成记&lt;/h2&gt;

&lt;p&gt;在这个互联网疯狂的年代，互联网似乎成为了我们这个世界的另一个维度，无论是各行各业都在为幻想着自己的互联网+模式，我们这这个维度中无所不能，似乎可能被互联网代替的产业最终都会失去它那一根最后的救命稻草。所以我希望在这个维度中有个自己的世界，这个域名表示着我，我的生活，我的学习，我的爱情希望都可以在这网站中记录。&lt;/p&gt;

&lt;p&gt;如果你恰好逛到了这里，希望你也能喜欢这个博客主题。&lt;/p&gt;

&lt;p&gt;—— Libao 记于 2015.12&lt;/p&gt;

</description>
        <pubDate>Wed, 14 Oct 2015 20:00:00 +0800</pubDate>
        <link>http://devxulibao.com/2015/10/14/hello-2015/</link>
        <guid isPermaLink="true">http://devxulibao.com/2015/10/14/hello-2015/</guid>
        
        <category>活着</category>
        
        <category>2015</category>
        
        <category>北京</category>
        
        
      </item>
    
      <item>
        <title>JavaScript Module Loader</title>
        <description>&lt;h2 id=&quot;foreword&quot;&gt;Foreword&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Here comes Module!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。&lt;/p&gt;

&lt;p&gt;于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;catalog&quot;&gt;Catalog&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;#commonjs--node&quot;&gt;CommonJS &amp;amp; Node&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#history&quot;&gt;History&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#requirejs--amd&quot;&gt;RequireJS &amp;amp; AMD&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#seajs--cmd&quot;&gt;SeaJS &amp;amp; CMD&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#amd-vs-cmd&quot;&gt;AMD vs CMD&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#webpack&quot;&gt;WebPack&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;commonjs--node&quot;&gt;CommonJS &amp;amp; Node&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Javascript: not just for browsers any more! —— CommonJS Slogen&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;前端模块化的事实标准之一，2009 年 8 月，&lt;a href=&quot;http://wiki.commonjs.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt; 诞生。&lt;/p&gt;

&lt;p&gt;CommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。&lt;/p&gt;

&lt;p&gt;让我们看看 Node 中的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper
// &quot;as though the module was wrapped in a function&quot;

var a = require(&#39;./a&#39;)  // 加载模块（同步加载）
a.doSomething()         // 等上一句执行完才会执行
  
exports.b = function(){ // 暴露 b 函数接口
  // do something
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;exports&lt;/code&gt;是一个内置对象，就像&lt;code&gt;require&lt;/code&gt;是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写&lt;code&gt;module.exports&lt;/code&gt;就可以了。&lt;/p&gt;

&lt;p&gt;CommonJS 前身叫 ServerJS ，&lt;strong&gt;后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS&lt;/strong&gt; 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。&lt;/p&gt;

&lt;p&gt;因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境）&lt;/li&gt;
  &lt;li&gt;虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。&lt;/li&gt;
  &lt;li&gt;都在向着 &lt;strong&gt;COMMON&lt;/strong&gt; 的方向进化：&lt;strong&gt;兼容不同风格，兼容浏览器和服务器两种环境&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文接下来要讨论的典例是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RequireJS &amp;amp; AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法）&lt;/li&gt;
  &lt;li&gt;SeaJS &amp;amp; CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;history&quot;&gt;History&lt;/h2&gt;

&lt;!--&lt;h2 id=&quot;history&quot;&gt; History &lt;/h2&gt;--&gt;

&lt;blockquote&gt;
  &lt;p&gt;此段落参考自玉伯的 &lt;a href=&quot;https://github.com/seajs/seajs/issues/588&quot;&gt;前端模块化开发那点历史&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules&quot;&gt;Modules/1.0&lt;/a&gt; 规范，并且在 Node.js 等环境下取得了很不错的实践。&lt;/p&gt;

&lt;p&gt;09年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Modules/1.x&lt;/strong&gt; 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/Transport&quot;&gt;Modules/Transport&lt;/a&gt; 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Modules/Async&lt;/strong&gt; 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition&quot;&gt;AMD&lt;/a&gt; 规范及其实现 &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt;。这个稍后再细说。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Modules/2.0&lt;/strong&gt; 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 &lt;code&gt;add&lt;/code&gt;和&lt;code&gt;use&lt;/code&gt; 两个源自于 YUI Modules 的函数名替换了 &lt;code&gt;define&lt;/code&gt; 和 &lt;code&gt;require&lt;/code&gt; ，但其原理更接近 RequireJS ，与 YUI Modules 的 &lt;code&gt;Y&lt;/code&gt; 沙箱 Attach 机制并不相同 &lt;/p&gt;

&lt;h2 id=&quot;requirejs--amd&quot;&gt;RequireJS &amp;amp; AMD&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition&quot;&gt;AMD (Async Module Definition)&lt;/a&gt; 是 RequireJS 在推广过程中对模块定义的规范化产出。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;RequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//CommonJS

var Employee = require(&quot;types/Employee&quot;);

function Programmer (){
    //do something
}  

Programmer.prototype = new Employee();

//如果 require call 是异步的，那么肯定 error
//因为在执行这句前 Employee 模块肯定来不及加载进来 
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以我们需要 &lt;strong&gt;Function Wrapping&lt;/strong&gt; 来获取依赖并且提前通过 script tag 提前加载进来&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//AMD Wrapper

define(
    [types/Employee],    //依赖
    function(Employee){  //这个回调会在所有依赖都被加载后才执行
    
        function Programmer(){
            //do something
        };
    
        Programmer.prototype = new Employee();
        return Programmer;  //return Constructor
    }
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当依赖模块非常多时，这种&lt;strong&gt;依赖前置&lt;/strong&gt;的写法会显得有点奇怪，所以 AMD 给了一个语法糖， &lt;strong&gt;simplified CommonJS wrapping&lt;/strong&gt;，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function (require) {
    var dependency1 = require(&#39;dependency1&#39;),
        dependency2 = require(&#39;dependency2&#39;);

    return function () {};
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The AMD loader will parse out the &lt;code&gt;require(&#39;&#39;)&lt;/code&gt; calls by using &lt;code&gt;Function.prototype.toString()&lt;/code&gt;, then internally convert the above define call into this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define([&#39;require&#39;, &#39;dependency1&#39;, &#39;dependency2&#39;], function (require) {
    var dependency1 = require(&#39;dependency1&#39;),
        dependency2 = require(&#39;dependency2&#39;);

    return function () {};
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出于&lt;code&gt;Function.prototype.toString()&lt;/code&gt;兼容性和性能的考虑，最好的做法还是做一次 &lt;strong&gt;optimized build&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;AMD 和 CommonJS 的核心争议如下：&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;1. &lt;strong&gt;执行时机&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Modules/1.0:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = require(&quot;./a&quot;) // 执行到此时，a.js 才同步下载并执行
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AMD: （使用 require 的语法糖时）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define([&quot;require&quot;],function(require)){
    // 在这里，a.js 已经下载并且执行好了
    // 使用 require() 并不是 AMD 的推荐写法
    var a = require(&quot;./a&quot;) // 此处仅仅是取模块 a 的 exports
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）&lt;/p&gt;

&lt;p&gt;但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2. &lt;strong&gt;书写风格&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;AMD 推荐的风格并不使用&lt;code&gt;require&lt;/code&gt;，而是通过参数传入，破坏了&lt;strong&gt;依赖就近&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;],function(a, b, c){
    // 提前申明了并初始化了所有模块
    
    true || b.foo(); //即便根本没用到模块 b，但 b 还是提前执行了。
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过，在笔者看来，风格喜好因人而异，主要还是&lt;strong&gt;预执行&lt;/strong&gt;和&lt;strong&gt;懒执行&lt;/strong&gt;的差异。&lt;/p&gt;

&lt;p&gt;另外，require 2.0 也开始思考异步处理&lt;strong&gt;软依赖&lt;/strong&gt;（区别于一定需要的&lt;strong&gt;硬依赖&lt;/strong&gt;）的问题，提出了这样的方案：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 函数体内：
if(status){
    async([&#39;a&#39;],function(a){
        a.doSomething()
    })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;seajs--cmd&quot;&gt;SeaJS &amp;amp; CMD&lt;/h2&gt;

&lt;p&gt;CMD (Common Module Definition) 是 &lt;a href=&quot;http://seajs.org/docs/&quot;&gt;SeaJS&lt;/a&gt; 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。&lt;/p&gt;

&lt;p&gt;不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CMD Specification
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/cmdjs/specification/blob/master/draft/module.md&quot;&gt;English (CMDJS-repo)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/242&quot;&gt;Chinese (SeaJS-repo)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CMD 主要有 define, factory, require, export 这么几个东西&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;define &lt;code&gt;define(id?, deps?, factory)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;factory &lt;code&gt;factory(require, exports, module)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;require &lt;code&gt;require(id)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;exports &lt;code&gt;Object&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CMD 推荐的 Code Style 是使用 CommonJS 风格的 &lt;code&gt;require&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports) {

    // 获取模块 a 的接口
    var a = require(&#39;./a&#39;);
    // 调用模块 a 的方法
    a.doSomething();
  
    // 对外提供 foo 属性
    exports.foo = &#39;bar&#39;;
    // 对外提供 doSomething 方法
    exports.doSomething = function() {};
  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(&#39;hello&#39;, [&#39;jquery&#39;], function(require, exports, module) {

    // 模块代码...
  
    // 直接通过 return 暴露接口
    return {
        foo: &#39;bar&#39;,
        doSomething: function() {}
    };

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。&lt;/p&gt;

&lt;h2 id=&quot;amd-vs-cmd&quot;&gt;AMD vs CMD&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对于依赖的模块，AMD 是&lt;strong&gt;提前执行&lt;/strong&gt;，CMD 是&lt;strong&gt;懒执行&lt;/strong&gt;。（都是先加载）
    &lt;ul&gt;
      &lt;li&gt;CMD 推崇&lt;strong&gt;依赖就近&lt;/strong&gt;，AMD 推崇&lt;strong&gt;依赖前置&lt;/strong&gt;。   &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// AMD 默认推荐

define([&#39;./a&#39;, &#39;./b&#39;], function(a, b) {  // 依赖前置，提前执行
  
    a.doSomething()
    b.doSomething()
  
})

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// CMD

define(function(require, exports, module) {
  
    var a = require(&#39;./a&#39;)
    a.doSomething()
  
    var b = require(&#39;./b&#39;) // 依赖就近，延迟执行
    b.doSomething() 
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;webpack&quot;&gt;WebPack&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;working…&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Mon, 25 May 2015 00:00:00 +0800</pubDate>
        <link>http://devxulibao.com/2015/05/25/js-module-loader/</link>
        <guid isPermaLink="true">http://devxulibao.com/2015/05/25/js-module-loader/</guid>
        
        <category>前端开发</category>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>「知乎」对中国用户而言，Pure Android 是否比 MIUI 或 Flyme 体验更好？</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;这篇文章转载自&lt;a href=&quot;http://www.zhihu.com/question/25104721/answer/30108886&quot;&gt;我在知乎上的回答&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;哎呀～不要站队嘛。其实这是一个很有意思的题目，让我们一点点来看
    &lt;br /&gt;
    &lt;br /&gt;哦对，谢妖～。本人是Nexus 5用户，系统当然是Pure Android KitKat啦（臭谷粉！点Down！喂喂喂我还没给结论呢）
    &lt;br /&gt;&lt;b&gt;毕竟是回答问题嘛，先给一个明确的答案&lt;/b&gt;：
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;否。（&lt;/b&gt;&lt;b&gt;对中国用户而言，Pure Android 并不比 MIUI 或 Flyme 体验更好。&lt;/b&gt;&lt;b&gt;）&lt;/b&gt;
    
    &lt;p&gt;从下面「 居然比关注数还多」的回答中，就可以看出大家都是急于站队的样子：&lt;/p&gt;
    
    &lt;ul&gt;
        &lt;li&gt;Google Service！翻墙很轻松好吗！Geek站过来，有品味绝逼原生阿。&lt;/li&gt;
        &lt;li&gt;没用过Pure，国内Google能用！？本地化多重要，易用果断MIUI/Flyme 啊！（咦 米粉和魅粉居然在一致对外上达成了共识）&lt;/li&gt;
    &lt;/ul&gt;
    &lt;br /&gt;从答案我们也可以看出，中国用户的确是一个过于复杂的群体，那这个问题怎么办？
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;数学老师教过哒，分类讨论啊！&lt;/b&gt;
    &lt;br /&gt;（来，开始认真了。注意，我只分两类，数量非常小的Geek用户，和其余都算在内的非Geek用户）
    &lt;br /&gt;
    &lt;br /&gt;

    &lt;p&gt;先说好理解的：&lt;/p&gt;
    
    &lt;ul&gt;
        &lt;li&gt;&lt;b&gt;为什么 Geek 用户 都爱使用Pure Android？：&lt;/b&gt;
        &lt;/li&gt;
    &lt;/ul&gt;在国内，使用Pure Android其实是有很多障碍的：众所周知Google基本被墙死，去年还能上上的G+，Gmail 最近基本报废，回国后Google Now不开VPN永远都是Sign error或者No internet connection……那干嘛还用？
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;因为这群人是Geek呀！&lt;/b&gt;这群谷粉、安卓粉、IT科技粉、设计师、工程师们，这群充满技术情节的人儿们，为了我们的品味（逼格），挂着VPN，连着美版的Play Store，用着Android/Material Design 的 GMS，Chrome Beta，FB，Twitter，WhatsApp……就这么一路高歌的走下去了。
    &lt;br /&gt;
    &lt;br /&gt;你看！Action Bar ＋ Navigation Drawer 多好用！
    &lt;br /&gt;你看！Fixed Tabs 可以滑的好吗！
    &lt;br /&gt;你看！流畅不！ART开起来妥妥的流畅度爆iOS！
    &lt;br /&gt;你看！原生Android 哪里会越用用卡！？你升4.4.4了吗 ？
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;哪里要担心这群人啊。&lt;/b&gt;国内买不到的Nexus，用不了GMS，这都不叫事。
    &lt;br /&gt;
    &lt;br /&gt;

    &lt;p&gt;那么，&lt;/p&gt;

    &lt;ul&gt;
        &lt;li&gt;&lt;b&gt;为什么 非Geek 用户 不适合使用Pure Android？：&lt;/b&gt;
        &lt;/li&gt;
    &lt;/ul&gt;GMS的问题就不多说了，妥妥是用不了，在VPN之间切换也是麻烦。
    &lt;br /&gt;也不说Pure Android不那么好刷到的问题（当然你可以刷CM），
    &lt;br /&gt;我们就直接来看最核心的问题：
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;「 Pure Android 的交互设计真的比 MIUI / Flyme 好吗？」&lt;br /&gt;&lt;/b&gt;
    &lt;br /&gt;&lt;b&gt;不见得。&lt;/b&gt;
    &lt;br /&gt;&lt;b&gt;所谓设计，第一个要考虑的就是目标用户。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;为什么Pure Android的交互设计让Geek觉得用户体验好？
    &lt;br /&gt;
    &lt;ul&gt;
        &lt;li&gt;国外规范的 Android Design 生态环境打造统一的 Pure Android 体验&lt;/li&gt;
        &lt;li&gt;更高级的手势/App运用带来了很多便利（典型的例子SwipePad）&lt;/li&gt;
        &lt;li&gt;有着工程师思想的他们可以轻易理解Android的复杂逻辑&lt;/li&gt;
        &lt;li&gt;有着工程师思想的他们总能自己轻松躲开一些设计问题&lt;/li&gt;
    &lt;/ul&gt;
    &lt;br /&gt;而 Pure Android 之于 普通用户 呢？
    &lt;br /&gt;&lt;b&gt;「 这些优势基本荡然无存」&lt;/b&gt;，反而，混乱的国内生态环境带来大部分中国用户对Android Design的陌生，相比iOS复杂许多的Android逻辑带来较高的学习成本……
    &lt;br /&gt;
    &lt;br /&gt;而MIUI/Flyme在设计方面上的本地化，主要就是出来解决这个问题的。
    &lt;br /&gt;我们可以看到，其实MIUI/Flyme做得大部分工作，除了视觉外，就是&lt;b&gt;简化信息层级，降低交互学习成本，遮住Android系统过于复杂的部分，在易用性上向iOS靠拢&lt;/b&gt;。
    &lt;br /&gt;
    &lt;br /&gt;如果说在这里MIUI/Flyme还只能和Pure Android 打个平手的话……
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;MIUI 和 Flyme 的本地化还远没有完：&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;你在国内总要用国内的互联网服务吧？
    &lt;br /&gt;&lt;b&gt;集成，&lt;/b&gt;我全给你全整合进来，打造一条龙服务
    &lt;br /&gt;
    &lt;ul&gt;
        &lt;li&gt;应用商店
            &lt;br /&gt;
        &lt;/li&gt;
        &lt;li&gt;云存储/云服务（自己提供或合作）
            &lt;br /&gt;
        &lt;/li&gt;
        &lt;li&gt;数字娱乐消费（音乐/游戏/阅读/视频/主题/壁纸/铃声……）
            &lt;br /&gt;
        &lt;/li&gt;
        &lt;li&gt;安全（小白最爱用的系统清理，陌生号码拦截……）
            &lt;br /&gt;
        &lt;/li&gt;
        &lt;li&gt;生活服务（支付，地图，快递，订餐，打车，旅游……）
            &lt;br /&gt;
        &lt;/li&gt;
        &lt;li&gt;社交（美图，快速分享……）
            &lt;br /&gt;
        &lt;/li&gt;
        &lt;li&gt;太多了。总之就是你想要什么有什么，自己没有就跟大家合作呗。
            &lt;br /&gt;
        &lt;/li&gt;
    &lt;/ul&gt;&lt;b&gt;不够酷？&lt;/b&gt;对大部分用户来说够酷了
    &lt;br /&gt;
    &lt;ul&gt;
        &lt;li&gt;小米，平板，盒子，电视，路由……MIUI的多屏体验&lt;/li&gt;
        &lt;li&gt;魅族，联合智能硬件，手表飞机插座……Connect to Meizu&lt;/li&gt;
    &lt;/ul&gt;&lt;b&gt;渠道成本低（不是指价格）&lt;/b&gt;。这个其实也相当重要
    &lt;br /&gt;
    &lt;ul&gt;
        &lt;li&gt;容易刷到，适配机子广，稳定。&lt;/li&gt;
        &lt;li&gt;国内买得到，线下甚至有体验店，可以教你用呀什么的。&lt;/li&gt;
    &lt;/ul&gt;
    &lt;br /&gt;更何况，对于大部分非Geek用户，手机虽不再只是当年的通讯工具那么简单，但充其量也就是一个智能电子设备而已。&lt;b&gt;能方便快速的享受到国内主流的互联网应用与服务，完成日常的需求就足以&lt;/b&gt;。
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;MIUI/Flyme 在这方面上的成绩，是Pure Android远不能比的。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;所以我的结论是：
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;对中国用户而言，Pure Android 并不比 MIUI 或 Flyme 体验更好。&lt;/b&gt;
    &lt;br /&gt;&lt;b&gt;对大部分中国用户而言，MIUI 或 Flyme 比 &lt;/b&gt;&lt;b&gt;Pure Android 的&lt;/b&gt;&lt;b&gt;体验更好。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;没啥利益相关，我又不是云OS的
&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Sep 2014 20:00:00 +0800</pubDate>
        <link>http://devxulibao.com/2014/09/04/is-pure-android-better/</link>
        <guid isPermaLink="true">http://devxulibao.com/2014/09/04/is-pure-android-better/</guid>
        
        <category>知乎</category>
        
        <category>交互设计</category>
        
        <category>Android</category>
        
        
      </item>
    
  </channel>
</rss>
